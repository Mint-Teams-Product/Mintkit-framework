export const pipe = function () { let e = arguments, t = e.length; for (let r = 0; r < t; r++)if ("function" != typeof e[r]) throw TypeError(`pipe: Argument at index ${r} is not a function`); return function (r) { let n = r; for (let o = 0; o < t; o++)try { n = e[o](n) } catch (s) { throw console.error(`pipe: Error in function at index ${o}:`, s), s } return n } }; export const compose = function () { let e = arguments, t = e.length; for (let r = 0; r < t; r++)if ("function" != typeof e[r]) throw TypeError(`compose: Argument at index ${r} is not a function`); return function (r) { let n = r; for (let o = t - 1; o >= 0; o--)try { n = e[o](n) } catch (s) { throw console.error(`compose: Error in function at index ${o}:`, s), s } return n } }; let clone = (() => { if ("function" == typeof globalThis.structuredClone) return t => { try { return globalThis.structuredClone(t) } catch (r) { return console.warn("structuredClone failed, falling back to custom clone.", r), e(t) } }; let e = (t, r = new WeakMap) => { if (Object(t) !== t || t instanceof Function) return t; if (r.has(t)) return r.get(t); try { if (t instanceof Date) return new Date(t); if (t instanceof RegExp) return RegExp(t.source, t.flags); if (t instanceof Map) { let n = new Map; return r.set(t, n), t.forEach((t, o) => n.set(e(o, r), e(t, r))), n } if (t instanceof Set) { let o = new Set; return r.set(t, o), t.forEach(t => o.add(e(t, r))), o } } catch (s) { return console.error("Could not clone a specific object type, returning as is.", s), t } let i = Array.isArray(t) ? [] : Object.create(Object.getPrototypeOf(t)); for (let a of (r.set(t, i), Reflect.ownKeys(t))) i[a] = e(t[a], r); return i }; return console.warn("Mintkit: `structuredClone` is not available. Using a custom fallback."), e })(); function createElement(e, t, ...r) { if (!e || "string" != typeof e) throw Error("createElement: tag must be a non-empty string"); let n = r.flat(1 / 0).filter(e => null != e && !1 !== e); return { tag: e, props: t || {}, children: n, key: t?.key || null } } function isSameNodeType(e, t) { return !!e && !!t && ("string" == typeof e || "number" == typeof e ? "string" == typeof t || "number" == typeof t : e.tag === t.tag && e.key === t.key) } function updateProps(e, t, r) { if (!e || !(e instanceof Element)) { console.warn("updateProps: Invalid DOM element"); return } r = r || {}, Object.keys(t = t || {}).forEach(n => { if (!(n in r)) { if (n.startsWith("on")) { let o = n.slice(2).toLowerCase(); e.removeEventListener(o, t[n]) } else "className" === n ? e.className = "" : "style" === n && "object" == typeof t[n] ? Object.keys(t[n]).forEach(t => { e.style[t] = "" }) : "key" !== n && e.removeAttribute(n) } }), Object.keys(r).forEach(n => { let o = t[n], s = r[n]; if (o !== s && "key" !== n) { if (n.startsWith("on") && "function" == typeof s) { let i = n.slice(2).toLowerCase(); o && e.removeEventListener(i, o), e.addEventListener(i, s) } else "className" === n ? e.className = s || "" : "style" === n ? "object" == typeof s ? Object.assign(e.style, s) : e.setAttribute("style", s) : "value" === n && ("INPUT" === e.tagName || "TEXTAREA" === e.tagName) ? e.value = s : "checked" === n && "INPUT" === e.tagName ? e.checked = Boolean(s) : e.setAttribute(n, s) } }) } function createDomNode(e) { if (null == e || !1 === e) return document.createTextNode(""); if ("string" == typeof e || "number" == typeof e) return document.createTextNode(String(e)); if (Array.isArray(e)) { let t = document.createDocumentFragment(); return e.forEach(e => { t.appendChild(createDomNode(e)) }), t } if (!e.tag) return console.warn("createDomNode: Invalid vNode", e), document.createTextNode(""); try { let r = document.createElement(e.tag); return updateProps(r, {}, e.props), e.children && e.children.length > 0 && e.children.forEach(e => { let t = createDomNode(e); t && r.appendChild(t) }), r } catch (n) { return console.error("createDomNode: Error creating element:", n), document.createTextNode(`[Error: ${e.tag}]`) } } function diff(e, t, r, n = 0) { if (!e || !(e instanceof Element)) { console.warn("diff: Invalid parent element"); return } try { if (r) { if (t) { if (typeof t == typeof r && ("string" != typeof t || t === r) && ("number" != typeof t || t === r) && isSameNodeType(t, r)) { if (t.tag) { let o = e.childNodes[n]; if (o) { updateProps(o, r.props, t.props); let s = t.children ? t.children.length : 0, i = r.children ? r.children.length : 0, a = Math.max(s, i); for (let l = 0; l < a; l++)diff(o, t.children ? t.children[l] : null, r.children ? r.children[l] : null, l) } } } else { let c = createDomNode(t), u = e.childNodes[n]; c && u && e.replaceChild(c, u) } } else { let h = e.childNodes[n]; h && e.removeChild(h) } } else { let d = createDomNode(t); d && e.appendChild(d) } } catch (f) { console.error("diff: Error during diffing:", f) } } export function createState(e) { let t = e, r = [], n = null, o = null, s = !1, i = [], a = () => { if (!s) { s = !0; try { let e = t; for (let l = 0, c = r.length; l < c; l++)if ("function" == typeof r[l]) try { r[l](e) } catch (u) { console.error("createState: Error in subscriber:", u) } if (o && null !== n && t && "object" == typeof t && t.vdom) try { diff(o, t.vdom, n), n = clone(t.vdom) } catch (h) { console.error("createState: Error during DOM diffing:", h) } } finally { if (s = !1, i.length > 0) { let d = i.shift(); d && (t = d, setTimeout(a, 0)) } } } }; return { get: function () { return t }, set: function (e) { let r = "function" == typeof e ? e(t) : e; if (r !== t) { if (s) { i.push(r); return } t = r, setTimeout(a, 0) } }, subscribe: function (e, s) { if ("function" == typeof e) return r.push(e), () => { let t = r.indexOf(e); t > -1 && r.splice(t, 1) }; if (s && s instanceof HTMLElement && (o = s, t && "object" == typeof t && t.vdom)) try { n = clone(t.vdom), o.innerHTML = ""; let i = createDomNode(t.vdom); i && o.appendChild(i) } catch (a) { console.error("createState: Error mounting initial DOM:", a) } }, createElement: createElement, getSubscriberCount: () => r.length, hasSubscribers: () => r.length > 0, clear() { r = [], n = null, o = null, i = [] } } } function isUnsafeCSS(e) { let t = [/expression\s*\(/i, /url\s*\(\s*['"]?javascript:/i, /@import\s+['"]?javascript:/i, /-moz-binding\s*:/i, /vbscript\s*:/i, /data\s*:\s*text\/html/i,].find(t => t.test(e)); if (t) { console.warn("isUnsafeCSS: The following pattern triggered the security check:", t.toString()); let r = e.match(t); return r && console.warn("isUnsafeCSS: The matched text was:", `"${r[0]}"`), !0 } return !1 } function sanitizeHTML(e) { return e.replace(/<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi, "").replace(/\son\w+\s*=\s*["'][^"']*["']/gi, "").replace(/javascript\s*:/gi, "") } function insertContent(e, t, r) { switch (r) { case "append": e.appendChild(t); break; case "prepend": e.insertBefore(t, e.firstChild); break; default: e.textContent = "", e.appendChild(t) } } function fnv1a(e) { let t = 2166136261; for (let r = 0; r < e.length; r++)t ^= e.charCodeAt(r), t += (t << 1) + (t << 4) + (t << 7) + (t << 8) + (t << 24); return ("0000000" + (t >>> 0).toString(16)).substr(-8) } let cssCache = new WeakMap, hashCache = new Map; export function injectCSS(e, t = {}) { let { nonce: r = null, media: n = null, priority: o = "normal", validate: s = !0, onError: i = console.error } = t; if (!e || "string" != typeof e) { let a = Error("injectCSS: Invalid CSS string provided"); return i(a), null } if (s && isUnsafeCSS(e)) { let l = Error("injectCSS: Potentially unsafe CSS detected"); throw i(l), l } let c = fnv1a(e + (r || "") + (n || "")); if (hashCache.has(c)) return hashCache.get(c); try { let u = document.createElement("style"); u.textContent = e, u.setAttribute("data-css-hash", c), u.setAttribute("data-injected", "true"), r && u.setAttribute("nonce", r), n && u.setAttribute("media", n); let h = "high" === o ? "afterbegin" : "beforeend"; return requestAnimationFrame(() => { document.head.insertAdjacentElement(h, u) }), u.removeCSS = () => { try { u.parentNode && u.parentNode.removeChild(u), cssCache.delete(u), hashCache.delete(c), u.textContent = "", u.removeCSS = null } catch (e) { i(e) } }, cssCache.set(u, c), hashCache.set(c, u), u } catch (d) { return i(Error(`injectCSS: Failed to inject CSS - ${d.message}`)), null } } export function injectHTML(e, t, r = {}) { let { sanitize: n = !0, allowScripts: o = !1, allowEvents: s = !1, mode: i = "replace", onError: a = console.error, validate: l = !0 } = r; if (!e || "string" != typeof e || "" === e.trim()) { let c = Error("injectHTML: targetSelector must be a non-empty string"); throw a(c), c } null == t && (t = ""); try { let u = document.querySelector(e); if (!u) throw Error(`injectHTML: No element matches selector: ${e}`); let h = String(t); h = h.replace(/<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi, "").replace(/ on\w+=\s*["'][^"']*["']/gi, "").replace(/ href=\s*["']javascript:[^"']*["']/gi, ' href="#"').replace(/ src=\s*["']javascript:[^"']*["']/gi, ' src="#"').replace(/ data:\s*[^"']*["']/gi, ""), !o && h.includes("<script") && (h = h.replace(/<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi, "")); let d = new DOMParser, f = d.parseFromString(`<template>${h}</template>`, "text/html"), m = f.querySelector("parsererror"); if (m) throw Error(`injectHTML: HTML parsing failed - ${m.textContent}`); let p = f.querySelector("template"); if (!p) throw Error("injectHTML: Template parsing failed"); document.createDocumentFragment(); let g = document.importNode(p.content, !0); removeEventHandlers(g); let y = document.createDocumentFragment(); for (; g.firstChild;) { let $ = g.firstChild; isNodeSafe($) && y.appendChild($.cloneNode(!0)), g.removeChild($) } return insertContent(u, y, i), u } catch (v) { let T = Error(`injectHTML: ${v.message}`); throw a(T), T } } function removeEventHandlers(e) { if (e.nodeType === Node.ELEMENT_NODE) { let t = e.getAttributeNames(); for (let r of t) r.startsWith("on") && r.length > 2 && e.removeAttribute(r); for (let n of e.children) removeEventHandlers(n) } } function isNodeSafe(e) { if (e.nodeType === Node.TEXT_NODE) return !0; if (e.nodeType === Node.ELEMENT_NODE) { let t = e.tagName.toLowerCase(); if (["script", "iframe", "object", "embed", "base"].includes(t)) return !1; let r = e.getAttributeNames(); for (let n of r) { if (n.startsWith("on") && n.length > 2) return !1; if ("href" === n || "src" === n) { let o = e.getAttribute(n) || ""; if (o.toLowerCase().startsWith("javascript:") || o.toLowerCase().startsWith("data:")) return !1 } } return !0 } return !1 } function insertContent(e, t, r) { switch (r) { case "append": e.appendChild(t); break; case "prepend": e.insertBefore(t, e.firstChild); break; default: for (; e.firstChild;)e.removeChild(e.firstChild); e.appendChild(t) } } export function clearInjectionCache() { hashCache.clear() } export function getInjectionStats() { return { hashCacheSize: hashCache.size, memoryUsage: performance.memory ? { used: performance.memory.usedJSHeapSize, total: performance.memory.totalJSHeapSize, limit: performance.memory.jsHeapSizeLimit } : "not available" } } export function injectTitle(e) { if (!e || "string" != typeof e) { console.warn("injectTitle: Invalid title string provided"); return } try { let t = document.head; t || (t = document.createElement("head"), document.documentElement.appendChild(t)); let r = t.querySelector("title"); r && r.remove(); let n = e.trim(); n.startsWith("<title>") && n.endsWith("</title>") || console.warn("injectTitle: Title string should be wrapped in <title> tags"), t.insertAdjacentHTML("beforeend", n); let o = t.querySelector("title"); o && console.debug("injectTitle: Title updated to:", o.textContent) } catch (s) { console.error("injectTitle: Error injecting title:", s) } } export async function get(e, t) { if (!e || "string" != typeof e) throw Error("get: url must be a string"); let r = e.toLowerCase(); if (r.endsWith(".css")) { if (document.querySelector(`link[href="${e}"]`)) return; return new Promise((t, r) => { let n = document.createElement("link"); n.rel = "stylesheet", n.href = e, n.onload = () => t(n), n.onerror = e => r(e), document.head.appendChild(n) }) } if (r.endsWith(".html") || r.endsWith(".htm")) { let n = await fetch(e); if (!n.ok) throw Error(`get: HTTP ${n.status}`); let o = await n.text(), s = t || "body", i = document.querySelector(s); if (i) return i.insertAdjacentHTML("beforeend", o), i; throw Error(`get: No element matches selector: ${s}`) } throw Error("get: Only .css, .html, .htm files are supported") } export const include = get; export async function processIncludes(e = document) { let t = /@include\(['"]([^'"]+)['"]\)/g, r = document.createTreeWalker(e.body || e, NodeFilter.SHOW_TEXT, null, !1), n, o = []; for (; n = r.nextNode();) { let s, i = n.nodeValue, a = !1; for (; s = t.exec(i);) { let l = s[1]; o.push((async () => { if (l.endsWith(".css")) await get(l); else if (l.endsWith(".html") || l.endsWith(".htm")) { let e = await fetch(l); if (e.ok) { let t = await e.text(); n.nodeValue = n.nodeValue.replace(s[0], t) } } })()), a = !0 } } await Promise.all(o) } export const AdjustHook = (e = {}) => { let t = { interval: e.interval || 1e3, endpoint: e.endpoint || "/reload", onReload: e.onReload || (() => location.reload()), onError: e.onError || (e => console.warn("AdjustHook: Reload check failed:", e)), onMetricsUpdate: e.onMetricsUpdate || null, enabled: !1 !== e.enabled, performanceMonitoring: e.performanceMonitoring || !1, detailedLogging: e.detailedLogging || !1, maxRetries: e.maxRetries || 3, retryDelay: e.retryDelay || 2e3, healthCheckInterval: e.healthCheckInterval || 3e4, metricsReportInterval: e.metricsReportInterval || 10 }; if (!t.enabled) return console.debug("AdjustHook: Hot reload disabled"), { stop() { }, getStats: () => ({}), getMetrics: () => ({}) }; let r = null, n = null, o = !1, s = Date.now(), i = { requests: { total: 0, successful: 0, failed: 0, retries: 0 }, performance: { totalTime: 0, avgResponseTime: 0, minResponseTime: 1 / 0, maxResponseTime: 0, lastResponseTime: 0, responseTimeHistory: [] }, errors: { total: 0, consecutive: 0, maxConsecutive: 0, types: {}, lastError: null, lastErrorTime: null }, health: { uptime: 0, isHealthy: !0, lastSuccessTime: Date.now(), lastFailureTime: null, successRate: 100 }, server: { memoryUsage: 0, cpuUsage: 0, uptime: 0, version: null, lastUpdate: null } }, a = e => { let t = i.performance; t.totalTime += e, t.lastResponseTime = e, t.minResponseTime = Math.min(t.minResponseTime, e), t.maxResponseTime = Math.max(t.maxResponseTime, e), t.avgResponseTime = t.totalTime / i.requests.total, t.responseTimeHistory.push(e), t.responseTimeHistory.length > 50 && t.responseTimeHistory.shift() }, l = e => { i.errors.total++, i.errors.consecutive++, i.errors.maxConsecutive = Math.max(i.errors.maxConsecutive, i.errors.consecutive), i.errors.lastError = e.message || e.toString(), i.errors.lastErrorTime = Date.now(); let t = e.name || "UnknownError"; i.errors.types[t] = (i.errors.types[t] || 0) + 1, i.health.isHealthy = i.errors.consecutive < 5, i.health.lastFailureTime = Date.now() }, c = () => { i.errors.consecutive = 0, i.health.isHealthy = !0, i.health.lastSuccessTime = Date.now() }, u = () => { i.health.uptime = Date.now() - s; let e = i.requests.successful + i.requests.failed; i.health.successRate = e > 0 ? i.requests.successful / e * 100 : 100 }, h = e => { if (0 === i.performance.responseTimeHistory.length) return 0; let t = [...i.performance.responseTimeHistory].sort((e, t) => e - t), r = Math.ceil(e / 100 * t.length) - 1; return t[Math.max(0, r)] }, d = () => { if (!t.performanceMonitoring) return; let e = { timestamp: new Date().toISOString(), uptime: i.health.uptime, requests: i.requests, performance: { ...i.performance, p50: h(50), p95: h(95), p99: h(99) }, errors: i.errors, health: i.health, server: i.server }; t.detailedLogging ? (console.group("AdjustHook Detailed Metrics"), console.table({ "Total Requests": i.requests.total, "Success Rate": `${i.health.successRate.toFixed(2)}%`, "Avg Response": `${i.performance.avgResponseTime.toFixed(2)}ms`, "P95 Response": `${h(95).toFixed(2)}ms`, "Consecutive Errors": i.errors.consecutive, "Health Status": i.health.isHealthy ? "Healthy" : "Degraded" }), console.groupEnd()) : console.log(`AdjustHook: ${i.requests.total} req, ${i.health.successRate.toFixed(1)}% success, ${i.performance.avgResponseTime.toFixed(1)}ms avg, ${i.errors.consecutive} consecutive errors`), t.onMetricsUpdate && t.onMetricsUpdate(e) }, f = () => { u(), t.detailedLogging && console.log(`AdjustHook Health Check: ${i.health.isHealthy ? "Healthy" : "Degraded"}`) }, m = async (e, r = t.maxRetries) => { for (let n = 1; n <= r; n++)try { return await e() } catch (o) { if (n === r) throw o; i.requests.retries++; let s = t.retryDelay * n; t.detailedLogging && console.warn(`AdjustHook: Retry ${n}/${r} in ${s}ms`), await new Promise(e => setTimeout(e, s)) } }, p = async () => { if (o) return; o = !0; let e = performance.now(); try { await m(async () => { i.requests.total++; let r = await fetch(t.endpoint, { method: "GET", cache: "no-cache", headers: { Accept: "application/json", "X-AdjustHook-Version": "2.0", "X-Request-ID": `${Date.now()}-${Math.random().toString(36).substr(2, 9)}` }, signal: AbortSignal.timeout(5e3) }); if (!r.ok) throw Error(`HTTP ${r.status}: ${r.statusText}`); let n = await r.json(), o = performance.now() - e; if (n.metrics && Object.assign(i.server, { memoryUsage: n.metrics.memory || 0, cpuUsage: n.metrics.cpu || 0, uptime: n.metrics.uptime || 0, version: n.metrics.version || null, lastUpdate: Date.now() }), a(o), i.requests.successful++, c(), n && n.reload) { console.info(`AdjustHook: Reload triggered by server (Response: ${o.toFixed(2)}ms, Memory: ${g(n.metrics?.memory || 0)})`), t.onReload(); return } i.requests.total % t.metricsReportInterval == 0 && d() }) } catch (r) { i.requests.failed++, l(r), (t.detailedLogging || "localhost" === location.hostname || "127.0.0.1" === location.hostname) && t.onError(r) } finally { o = !1, u() } }, g = e => { if (0 === e) return "0 B"; let t = ["B", "KB", "MB", "GB"], r = Math.floor(Math.log(e) / Math.log(1024)); return parseFloat((e / Math.pow(1024, r)).toFixed(2)) + " " + t[r] }; return r = setInterval(p, t.interval), n = setInterval(f, t.healthCheckInterval), console.debug(`AdjustHook: Started monitoring (${t.interval}ms interval, ${t.maxRetries} retries, health check every ${t.healthCheckInterval}ms)`), { stop() { r && (clearInterval(r), r = null), n && (clearInterval(n), n = null), console.debug("AdjustHook: Stopped"), t.performanceMonitoring && (console.log("AdjustHook Final Report:"), d()) }, getStats: () => ({ requests: i.requests.total, errors: i.errors.total, totalTime: i.performance.totalTime, avgTime: i.performance.avgResponseTime, lastCheckTime: i.performance.lastResponseTime }), getMetrics: () => ({ ...i, summary: { uptime: i.health.uptime, successRate: i.health.successRate, avgResponseTime: i.performance.avgResponseTime, p95ResponseTime: h(95), healthStatus: i.health.isHealthy ? "healthy" : "degraded" } }), reportMetrics: d, getLastCheckTime: () => i.performance.lastResponseTime, isHealthy: () => i.health.isHealthy, getFormattedMetrics: () => ({ uptime: y(i.health.uptime), successRate: `${i.health.successRate.toFixed(2)}%`, avgResponse: `${i.performance.avgResponseTime.toFixed(2)}ms`, memoryUsage: g(i.server.memoryUsage), totalRequests: i.requests.total.toLocaleString(), errorRate: `${(i.requests.failed / i.requests.total * 100).toFixed(2)}%` }) }; function y(e) { let t = Math.floor(e / 1e3), r = Math.floor(t / 60), n = Math.floor(r / 60); return n > 0 ? `${n}h ${r % 60}m` : r > 0 ? `${r}m ${t % 60}s` : `${t}s` } }; export const MintUtils = { isElement: e => e instanceof Element, isTextNode: e => e instanceof Text, isVNode: e => e && "object" == typeof e && "tag" in e, debounce(e, t) { let r; return function n(...o) { let s = () => { clearTimeout(r), e(...o) }; clearTimeout(r), r = setTimeout(s, t) } }, deepEqual: function e(t, r) { if (t === r) return !0; if (null == t || null == r) return t === r; if (t.constructor !== r.constructor) return !1; if (Array.isArray(t)) { if (t.length !== r.length) return !1; for (let n = 0; n < t.length; n++)if (!e(t[n], r[n])) return !1; return !0 } let o = Object.keys(t), s = Object.keys(r); if (o.length !== s.length) return !1; for (let i of o) if (!Object.prototype.hasOwnProperty.call(r, i) || !e(t[i], r[i])) return !1; return !0 } }; export const PerformanceMonitor = { timers: new Map, enabled: !1, start(e) { return this.enabled && this.timers.set(e, performance.now()), this }, end(e) { if (!this.enabled) return 0; let t = this.timers.get(e); if (t) { let r = performance.now() - t; return this.timers.delete(e), console.log(`${e}: ${r.toFixed(2)}ms`), r } return 0 }, measure(e, t) { this.start(e); let r = t(); return this.end(e), r }, async measureAsync(e, t) { this.start(e); let r = await t(); return this.end(e), r }, getStats() { let e = {}; for (let [t, r] of this.timers) e[t] = performance.now() - r; return e }, clear() { this.timers.clear() }, enable() { this.enabled = !0, console.log("PerformanceMonitor enabled.") }, disable() { this.enabled = !1 } }; export const ReloadPerformanceTracker = { history: [], maxHistory: 25, enabled: !1, recordReload(e, t = 0, r = 0) { if (!this.enabled) return null; let n = { timestamp: Date.now(), duration: e, fileCount: t, memoryUsage: r, date: new Date().toISOString() }; return this.history.push(n), this.history.length > this.maxHistory && this.history.shift(), console.log(`Reload recorded: ${e.toFixed(2)}ms, Files: ${t}, Memory: ${r} bytes`), n }, getStats() { if (0 === this.history.length) return null; let e = this.history.map(e => e.duration), t = e.reduce((e, t) => e + t, 0) / e.length; return { totalReloads: this.history.length, averageTime: t, minTime: Math.min(...e), maxTime: Math.max(...e), lastReload: this.history[this.history.length - 1] } }, logStats() { if (!this.enabled) return; let e = this.getStats(); e && (console.log("Reload Performance Stats:"), console.log(`   Total reloads: ${e.totalReloads}`), console.log(`   Average time: ${e.averageTime.toFixed(2)}ms`), console.log(`   Min time: ${e.minTime.toFixed(2)}ms`), console.log(`   Max time: ${e.maxTime.toFixed(2)}ms`), console.log(`   Last reload: ${e.lastReload.duration.toFixed(2)}ms`)) }, clear() { this.history = [] }, enable() { this.enabled = !0, console.log("ReloadPerformanceTracker enabled.") }, disable() { this.enabled = !1 } }; export const Router = (() => { let e = window.location.pathname, t = {}, r = [], n = null; function o(e, t) { let r = e.split("/").filter(Boolean), n = t.split("/").filter(Boolean); if (r.length !== n.length && !e.includes("[...")) return null; let o = {}; for (let s = 0; s < r.length; s++)if (r[s].startsWith(":")) { let i = r[s].substring(1); o[i] = decodeURIComponent(n[s] || "") } else if (r[s].startsWith("[...") && r[s].endsWith("]")) { let a = r[s].substring(4, r[s].length - 1); o[a] = decodeURIComponent(n.slice(s).join("/") || ""); break } else if (r[s] !== n[s]) return null; return { params: o, match: !0 } } function s() { let s = !1; for (let i of r) { let a = o(i.pattern, e); if (a) { t = a.params, i.callback(a.params), s = !0; break } } !s && n && n(e) } return window.addEventListener("popstate", () => { e = window.location.pathname, s() }), { route(e, t) { return r.push({ pattern: e, callback: t }), this }, notFound(e) { return n = e, this }, navigate(t) { window.history.pushState({}, "", t), e = t, s() }, getParams: () => ({ ...t }), getPath: () => e, init() { return s(), this } } })(); export function navigate(e) { Router.navigate(e) } export function Link(e, ...t) { return createElement("a", { href: e.to, onClick(t) { t.preventDefault(), navigate(e.to) }, ...e }, ...t) } export function withRouter(e) { return t => { let r = createState({ path: Router.getPath(), params: Router.getParams() }), n = Router.route("*", e => { r.set({ path: Router.getPath(), params: Router.getParams() }) }), o = t.onUnmount; return t.onUnmount = () => { n(), o && o() }, e({ ...t, router: r.get() }) } }